{
    "preds"  :  [
        "clock[VARI] < clock[VARJ]",
        "clock[VARI] = clock[VARJ]",
        "clock[VARJ] = req[VARI][VARI]",
        "clock[VARJ] > req[VARI][VARI]",
        "\\A mi \\in 1 .. Len(network[VARJ][VARI]) : network[VARJ][VARI][mi].type = \"req\" => network[VARJ][VARI][mi].clock > req[VARI][VARI]",
        "\\A mi \\in 1 .. Len(network[VARI][VARJ]) : network[VARI][VARJ][mi].type = \"req\" => network[VARI][VARJ][mi].clock = req[VARI][VARI]",
        "VARI \\in ack[VARI]",
        "VARI \\in ack[VARJ]",
        "VARJ \\in ack[VARI]",
        "VARI # VARJ /\\ crit = crit",
        "VARI # VARJ /\\ ack = ack",
        "VARI # VARJ /\\ clock = clock",
        "VARI # VARJ /\\ network = network",
        "VARI # VARJ /\\ req = req",
        "ack[VARI] = {}",
        "ack[VARI] = Proc",
        "\\A VOTHER \\in Proc \\ {VARI} : beats(VARI,VOTHER) /\\ req = req",
        "VARI \\in crit",
        "VARJ \\in crit",
        "req[VARI][VARI] = 0",
        "req[VARI][VARI] > 0",
        "req[VARI][VARJ] = 0",
        "req[VARI][VARJ] > 0",
        "req[VARI][VARJ] > req[VARJ][VARJ]",
        "req[VARI][VARI] > req[VARI][VARJ]",
        "req[VARI][VARI] = req[VARI][VARJ]",
        "req[VARI][VARJ] > req[VARI][VARK]",
        "req[VARI][VARJ] = req[VARI][VARK]",
        "req[VARI][VARJ] = req[VARI][VARI]",
        "VARI < VARJ /\\ ack = ack",
        "network[VARI][VARI] # <<>>",
        "network[VARI][VARJ] # <<>>",
        "network[VARJ][VARI] # <<>>",
        "network[VARJ][VARI] # <<>> /\\ req[VARI][VARJ] = Head(network[VARJ][VARI]).clock",
        "network[VARJ][VARI] # <<>> /\\ req[VARI][VARJ] > Head(network[VARJ][VARI]).clock",
        "network[VARI][VARJ] # <<>> /\\ req[VARI][VARJ] = Head(network[VARI][VARJ]).clock",
        "network[VARI][VARJ] # <<>> /\\ req[VARI][VARJ] > Head(network[VARI][VARJ]).clock",
        "network[VARI][VARJ] # <<>> /\\ req[VARJ][VARI] > Head(network[VARI][VARJ]).clock",
        "req[VARI][VARI] = network[VARI][VARJ][VARRINDI].clock",
        "req[VARJ][VARI] = network[VARI][VARJ][VARRINDI].clock",
        "req[VARJ][VARI] > network[VARI][VARJ][VARRINDI].clock",
        "network[VARI][VARJ][VARRINDI].type = \"ack\"",
        "network[VARI][VARJ][VARRINDI].type = \"rel\"",
        "network[VARI][VARJ][VARRINDI].type = \"req\"",
        "network[VARI][VARJ][VARRINDI].clock = clock[VARI]",
        "network[VARI][VARJ][VARRINDI].clock > clock[VARI]",
        "network[VARI][VARJ][VARRINDI].clock = req[VARI][VARI]",
        "network[VARI][VARJ][VARRINDI].clock > req[VARI][VARI]",
        "network[VARI][VARJ] # <<>> /\\ Head(network[VARI][VARJ]).type = \"ack\"",
        "network[VARI][VARJ] # <<>> /\\ Head(network[VARI][VARJ]).type = \"rel\"",
        "network[VARI][VARJ] # <<>> /\\ Head(network[VARI][VARJ]).type = \"req\"",
        "network[VARI][VARJ] # <<>> /\\ req[VARI][VARJ] = Head(network[VARI][VARJ]).clock",
        "network[VARI][VARJ] # <<>> /\\ Head(network[VARI][VARJ]).clock = clock[VARI]",
        "network[VARI][VARJ] # <<>> /\\ Head(network[VARI][VARJ]).clock > clock[VARI]",
        "beats(VARI,VARJ) /\\ req = req",
        "beats(VARJ,VARI) /\\ req = req",
        "Precedes(network[VARI][VARJ], \"req\", \"rel\")",
        "Precedes(network[VARJ][VARI], \"req\", \"rel\")",
        "Precedes(network[VARJ][VARI], \"ack\", \"req\")",
        "Precedes(network[VARI][VARJ], \"req\", \"ack\")",
        "Precedes(network[VARI][VARJ], \"rel\", \"ack\")",
        "Contains(network[VARI][VARJ], \"req\")",
        "Contains(network[VARJ][VARI], \"req\")",
        "Contains(network[VARI][VARJ], \"rel\")",
        "Contains(network[VARJ][VARI], \"rel\")",
        "Contains(network[VARI][VARJ], \"ack\")",
        "Contains(network[VARJ][VARI], \"ack\")",
        "Count(network[VARI][VARJ], \"req\") <= 1",
        "Count(network[VARI][VARJ], \"rel\") <= 1",
        "Count(network[VARI][VARJ], \"ack\") <= 1"
    ],
    "action_local_preds":{
    },
    "preds_alt" : [],
    "safety"  :  "Mutex",
    "constants"  : {
        "N": "3",
        "maxClock": "4",
        "Nats": "{0,1,2,3,4,5}"
    },
    "actions": [],
    "constraint"  :  "ClockConstraint",
    "quant_inv"  :  "\\A VARI \\in Proc : \\A VARJ \\in Proc : \\A VARK \\in Proc : \\A VARRINDI \\in DOMAIN network[VARI][VARJ] : ",
    "quant_inv_alt"  :  null,
    "quant_vars": ["VARI", "VARJ", "VARMVAL", "VARMACK", "VARMINV"],
    "model_consts"  :  "",
    "symmetry" : false,
    "typeok"  :  "TypeOKRandom",
    "try_final_minimize": false,
    "max_tlc_inv_depth": 100,
    "simulation_inv_check": false,
    "simulation_inv_check_num_states": 2500000,
    "simulation_inv_check_depth": 35,
    "simulate"  :  true,
    "tlaps_proof_config": {
        "assumes": [
        ],
        "global_def_expands":[
            "Contains",
            "Count"
        ],
        "lemma_def_expands": {
            "Safety": ["Mutex"]
        },
        "action_def_expands":{
            "EnterAction": ["beats"],
            "ExitAction": ["beats", "Broadcast"],
            "ReceiveAckAction": ["beats"],
            "ReceiveReleaseAction": ["beats"]
        }
    }
}